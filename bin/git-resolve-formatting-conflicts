#!/bin/bash

# git-resolve-formatting-conflicts
# Copyright (c) 2025 Robert (Jamie) Munro
# Licensed under the MIT License
#
# This script automatically resolves formatting-related Git merge conflicts
# in various file types by applying Prettier and ESLint (if applicable) to
# all conflicting versions (base, ours, theirs) before performing a three-way merge.
#
# Part of Jamie's Git Tools: https://github.com/rjmunro/jamies-git-tools

# Exit immediately if a command exits with a non-zero status.
# Treat unset variables as an error when substituting.
# The exit status of a pipeline is the status of the last command to exit with a non-zero status,
# or zero if all commands in the pipeline exit successfully.
set -euo pipefail

REMOVE_INDENTATION=false
file_globs=()

print_help() {
  echo "Usage: $0 [-help|-h] [--remove-indentation] [file-glob ...]"
  echo "  --remove-indentation   Remove indentation from non-md/txt/py files after formatting."
  echo "                         Useful where indentation has caused conflicts, e.g. because something has been wrapped in an if statement."
  echo "                         You should manually re-apply a formatting tool to fix indentation after running this script."
  echo "  --help, -h             Show this help message."
  echo "  file-glob              Only process conflicted files matching these globs. By default all conflicted files are processed."
  exit 1
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --remove-indentation)
      REMOVE_INDENTATION=true
      shift
      ;;
    --help|-h)
      print_help
      exit 0
      ;;
    -*)
      echo "Unknown option: $1"
      print_help
      exit 1
      ;;
    *)
      file_globs+=("$1")
      shift
      ;;
  esac
done

# Determine the root directory of the Git repository.
# This ensures the script can be run from any subdirectory within the repo.
ROOT="$(git rev-parse --show-toplevel)"
# Change the current directory to the Git repository root.
cd "$ROOT"

# --- Detect available formatters based on config files ---
detect_formatters() {
  local has_prettier=false
  local has_eslint=false
  local has_black=false
  local has_rustfmt=false

  # Check for Prettier config files
  if [[ -f .prettierrc || -f .prettierrc.json || -f .prettierrc.js || -f .prettierrc.yml || -f .prettierrc.yaml || -f prettier.config.js ]] || grep -q '"prettier"' package.json 2>/dev/null; then
    if command -v npx >/dev/null 2>&1 && npx prettier --version >/dev/null 2>&1; then
      has_prettier=true
      echo "  Detected: Prettier (config found)"
    fi
  fi

  # Check for ESLint config files
  if [[ -f .eslintrc || -f .eslintrc.js || -f .eslintrc.json || -f .eslintrc.yml || -f .eslintrc.yaml || -f eslint.config.js ]] || grep -q '"eslint"' package.json 2>/dev/null; then
    if command -v npx >/dev/null 2>&1 && npx eslint --version >/dev/null 2>&1; then
      has_eslint=true
      echo "  Detected: ESLint (config found)"
    fi
  fi

  # Check for Black config (pyproject.toml with black section or .black file)
  if [[ -f pyproject.toml ]] && grep -q '\[tool\.black\]' pyproject.toml 2>/dev/null; then
    if command -v black >/dev/null 2>&1; then
      has_black=true
      echo "  Detected: Black (config found)"
    fi
  fi

  # Check for rustfmt config
  if [[ -f rustfmt.toml || -f .rustfmt.toml ]] && command -v rustfmt >/dev/null 2>&1; then
    has_rustfmt=true
    echo "  Detected: rustfmt (config found)"
  fi

  # Export detected formatters
  export HAS_PRETTIER=$has_prettier
  export HAS_ESLINT=$has_eslint
  export HAS_BLACK=$has_black
  export HAS_RUSTFMT=$has_rustfmt
}

# --- Define the formatting function ---
# This function encapsulates the actual formatting commands using detected formatters.
# It attempts to format the file using appropriate tools based on file type and available configs.
# The first argument ($1) to this function is the path to the file to be formatted.
# IMPORTANT: This function expects to operate on a file path within the actual Git repository
# structure, so that formatters can correctly discover their configuration files.
format_file() {
  local file_path="$1"
  local file_extension="${file_path##*.}" # Extract file extension
  local formatted=false

  echo "  --> Formatting $file_path"

  # Apply formatters based on file type and detected configs
  case "$file_extension" in
    js|jsx|ts|tsx|vue)
      # ESLint for JavaScript/TypeScript files
      if [[ "$HAS_ESLINT" == "true" ]]; then
        if npx eslint --fix --quiet "$file_path" 2>/dev/null; then
          echo "    ESLint --fix applied successfully"
          formatted=true
        else
          echo "    Warning: ESLint --fix failed for $file_path"
        fi
      fi

      # Prettier for these files (if available)
      if [[ "$HAS_PRETTIER" == "true" ]]; then
        if npx prettier --write --loglevel silent "$file_path" 2>/dev/null; then
          echo "    Prettier applied successfully"
          formatted=true
        else
          echo "    Warning: Prettier failed for $file_path"
        fi
      fi
      ;;
    py)
      # Black for Python files
      if [[ "$HAS_BLACK" == "true" ]]; then
        if black --quiet "$file_path" 2>/dev/null; then
          echo "    Black applied successfully"
          formatted=true
        else
          echo "    Warning: Black failed for $file_path"
        fi
      elif [[ "$HAS_PRETTIER" == "true" ]]; then
        # Fallback to Prettier if Black not available
        if npx prettier --write --loglevel silent "$file_path" 2>/dev/null; then
          echo "    Prettier applied successfully"
          formatted=true
        fi
      fi
      ;;
    rs)
      # rustfmt for Rust files
      if [[ "$HAS_RUSTFMT" == "true" ]]; then
        if rustfmt "$file_path" 2>/dev/null; then
          echo "    rustfmt applied successfully"
          formatted=true
        else
          echo "    Warning: rustfmt failed for $file_path"
        fi
      fi
      ;;
    *)
      # For other file types, try Prettier if available
      if [[ "$HAS_PRETTIER" == "true" ]]; then
        if npx prettier --write --loglevel silent "$file_path" 2>/dev/null; then
          echo "    Prettier applied successfully"
          formatted=true
        else
          echo "    Prettier skipped $file_path (unsupported file type)"
        fi
      fi
      ;;
  esac

  if [[ "$formatted" == "false" ]]; then
    echo "    No formatters applied to $file_path"
  fi

  # Optionally remove indentation except for .md, .txt, .py files
  if [[ "$REMOVE_INDENTATION" == "true" && "$file_extension" != "md" && "$file_extension" != "txt" && "$file_extension" != "py" ]]; then
    sed -i.bak 's/^[ \t]*//' "$file_path"
    echo "    Indentation removed"
  fi
}

# Detect available formatters before processing
echo "Detecting available formatters..."
detect_formatters

# Warn if no formatters detected
if [[ "$HAS_PRETTIER" == "false" && "$HAS_ESLINT" == "false" && "$HAS_BLACK" == "false" && "$HAS_RUSTFMT" == "false" ]]; then
  echo "Warning: No formatter config files detected. The script will still attempt three-way merge but without formatting."
  echo "Consider adding .prettierrc, .eslintrc, pyproject.toml, or rustfmt.toml to enable automatic formatting."
fi

# Get a list of all files that are currently in a merge conflict state (`--diff-filter=U`).
# We are now checking all conflicted files, and Prettier/ESLint will determine applicability.
if [ ${#file_globs[@]} -eq 0 ]; then
  conflicted_files=$(git diff --name-only --diff-filter=U)
else
  conflicted_files=$(git diff --name-only --diff-filter=U -- "${file_globs[@]}")
fi

# Check if the 'conflicted_files' variable is empty.
if [ -z "$conflicted_files" ]; then
  echo "No conflicted files found."
  exit 0 # Exit successfully if no conflicts are found.
fi

# Loop through each conflicted file found.
for file in $conflicted_files; do
  echo "Processing conflict in: $file"

  # Create temporary files to hold the *formatted* versions of base and theirs.
  # The 'ours' version will be formatted directly in $file and then used by merge-file.
  base_formatted_temp=$(mktemp)
  theirs_formatted_temp=$(mktemp)

  # --- Process and Format the 'Base' Version (Common Ancestor) ---
  # Extract the base version's content and write it directly to the actual file path.
  git show ":1:$file" > "$file"
  # Format the file in-place. Prettier/ESLint can now find their configs relative to $file.
  format_file "$file"
  # Copy the *formatted* content of the base version to a temporary file.
  cp "$file" "$base_formatted_temp"

  # --- Process and Format the 'Theirs' Version (Incoming) ---
  # Extract the theirs version's content and write it directly to the actual file path.
  git show ":3:$file" > "$file"
  # Format the file in-place.
  format_file "$file"
  # Copy the *formatted* content of the theirs version to a temporary file.
  cp "$file" "$theirs_formatted_temp"

  # --- Process and Format the 'Local' Version (Ours) ---
  # Extract the ours version's content and write it directly to the actual file path.
  git show ":2:$file" > "$file"
  # Format the file in-place. This '$file' will now contain your formatted local version
  # and will serve as the primary file for the three-way merge (modified in-place by git-merge-file).
  format_file "$file"

  # Perform a three-way merge using 'git merge-file'.
  # -L flags provide labels for the conflict markers in case a conflict still exists.
  # "$file" is the original file path, which now contains the formatted 'ours' version,
  # and will be modified in place with the final merge result.
  # "$base_formatted_temp" is the formatted common ancestor version.
  # "$theirs_formatted_temp" is the formatted other version.
  # Check the merge_exit_code to determine if the merge was clean or had conflicts.
  if git merge-file -L current -L base -L other "$file" "$base_formatted_temp" "$theirs_formatted_temp"; then
    echo "    Merge for $file was clean. Staging the resolved file."
    git add "$file" # Automatically stage the file if the merge was clean.
  else
    echo "    Warning: Merge for $file resulted in conflicts."
    echo "    Manual resolution is still required for $file. It has NOT been staged."
  fi

  # Clean up the temporary files created for this conflict.
  rm "$base_formatted_temp" "$theirs_formatted_temp"
done

echo "âœ… All formatting merge conflicts processed."
echo "Review any files that still have conflicts and stage them manually."
