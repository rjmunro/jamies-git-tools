#!/bin/bash

# watch-ci
# Copyright (c) 2025 Robert (Jamie) Munro
# Licensed under the MIT License
#
# Watch the CI status of a branch and notify when it's done
# Usage: watch-ci [branch]
# If no branch is specified, it will use the current branch
#
# Part of Jamie's Git Tools: https://github.com/rjmunro/jamies-git-tools

set -euo pipefail
# Requires: gh (GitHub CLI - https://cli.github.com/)
# Uses osascript and say from macOS to display notifications and speak the status
# Requires: notify-send or zenity for Linux to display notifications

QUIET=false
BRANCHES=()

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --quiet|-q)
      QUIET=true
      shift
      ;;
    --help|-h)
      echo "Usage: $0 [--quiet] [branch1] [branch2] ..."
      echo ""
      echo "Watch the CI status of one or more branches and notify when they're done."
      echo ""
      echo "Options:"
      echo "  --quiet, -q    Suppress audio notifications"
      echo "  --help, -h     Show this help"
      echo ""
      echo "Arguments:"
      echo "  branch         Branch(es) to monitor (default: current branch)"
      echo ""
      echo "Examples:"
      echo "  $0                    # Monitor current branch"
      echo "  $0 feature-branch     # Monitor one branch"
      echo "  $0 main develop       # Monitor multiple branches"
      echo "  $0 --quiet branch1 branch2  # Monitor quietly"
      exit 0
      ;;
    -*)
      echo "Unknown option: $1"
      echo "Use --help for usage information"
      exit 1
      ;;
    *)
      BRANCHES+=("$1")
      shift
      ;;
  esac
done

# If no branches specified, use current branch
if [[ ${#BRANCHES[@]} -eq 0 ]]; then
  BRANCHES=($(git rev-parse --abbrev-ref HEAD))
fi

# Check if gh is available
if ! command -v gh >/dev/null 2>&1; then
  echo "Error: 'gh' command not found. Please install GitHub CLI: https://cli.github.com/"
  exit 1
fi

PROJECT="$(basename "$(git rev-parse --show-toplevel)")"

# Function to send notification for a completed branch
send_notification() {
  local branch="$1"
  local status="$2"
  local short_branch="${branch#rjmunro/}"

  # If we are on MacOS, use `terminal-notifier` to display a notification and `say` to speak the status
  if [ "$(uname)" = "Darwin" ]; then
    terminal-notifier -title "CI Status for $PROJECT" -message "Branch $short_branch CI Status: $status"
    if [[ "$QUIET" != "true" ]]; then
      say "CI done on branch $short_branch. Status: $status"
    fi

  # If notify-send is available, use it to display a notification
  elif command -v notify-send &> /dev/null; then
    notify-send "Branch $short_branch CI Status: $status" "CI Status"

  # If notify-send is not available, use zenity to display a notification
  elif command -v zenity &> /dev/null; then
    zenity --notification --text "Branch $short_branch CI Status: $status" --title "CI Status"

  # If we are on Windows, use PowerShell to display a notification
  elif [ "$(uname)" = "MINGW64_NT-10.0" ]; then
    powershell -Command "New-BurntToastNotification -Text 'Branch $short_branch CI Status: $status'"
    if [[ "$QUIET" != "true" ]]; then
      powershell -Command "Add-Type -AssemblyName System.Speech; (New-Object System.Speech.Synthesis.SpeechSynthesizer).Speak('CI done on branch $short_branch. Status: $status')"
    fi
  fi
}

# Function to get CI status for a branch
get_ci_status() {
  local branch="$1"
  local sha

  # Get the SHA for the branch
  sha=$(git rev-parse "$branch" 2>/dev/null) || return 1

  # Try to get the PR status first (most reliable)
  local pr_json
  if pr_json=$(gh pr view "$branch" --json statusCheckRollup 2>/dev/null); then
    local conclusion=$(echo "$pr_json" | grep -o '"conclusion":"[^"]*"' | head -1 | cut -d'"' -f4)
    local state=$(echo "$pr_json" | grep -o '"state":"[^"]*"' | head -1 | cut -d'"' -f4)

    # Map GitHub check states to hub-style outputs
    if [[ "$state" == "PENDING" || "$state" == "IN_PROGRESS" ]]; then
      echo "pending"
      return 0
    elif [[ "$conclusion" == "SUCCESS" ]]; then
      echo "success"
      return 0
    elif [[ "$conclusion" == "FAILURE" ]]; then
      echo "failure"
      return 1
    elif [[ "$conclusion" == "CANCELLED" ]]; then
      echo "error"
      return 1
    fi
  fi

  # Fall back to checking workflow runs directly
  local run_json
  if run_json=$(gh run list --branch "$branch" --limit 1 --json status,conclusion 2>/dev/null); then
    local status=$(echo "$run_json" | grep -o '"status":"[^"]*"' | head -1 | cut -d'"' -f4)
    local conclusion=$(echo "$run_json" | grep -o '"conclusion":"[^"]*"' | head -1 | cut -d'"' -f4)

    if [[ "$status" == "in_progress" || "$status" == "queued" ]]; then
      echo "pending"
      return 0
    elif [[ "$conclusion" == "success" ]]; then
      echo "success"
      return 0
    elif [[ "$conclusion" == "failure" ]]; then
      echo "failure"
      return 1
    elif [[ -n "$conclusion" ]]; then
      echo "error"
      return 1
    fi
  fi

  # No status found
  echo "no status"
  return 0
}

# Function to open PR page for a branch
open_pr_page() {
  local branch="$1"
  echo "Opening PR page for $branch..."

  # Try to view existing PR
  if gh pr view "$branch" --web 2>/dev/null; then
    return 0
  fi

  # No PR exists, open the PR creation page in the browser
  # This will open GitHub's PR creation UI with the branch pre-selected
  gh pr create --web --head "$branch" 2>/dev/null || true
}

# Initialize tracking
PENDING_BRANCHES=()      # Array of branches still being monitored
COMPLETED_BRANCHES=()    # Array of completed branches
OVERALL_EXIT_CODE=0

# Initialize all branches
for branch in "${BRANCHES[@]}"; do
  PENDING_BRANCHES+=("$branch")
  echo "Starting to monitor: $branch"
done

# Constants
MAX_INITIAL_TRIES=5      # How many 15-second cycles to wait for "no status" branches
GLOBAL_TRIES=0           # Global counter for initial "no status" period

# Main monitoring loop
while [[ ${#PENDING_BRANCHES[@]} -gt 0 ]]; do
  NEW_PENDING=()

  # Check each pending branch
  for branch in "${PENDING_BRANCHES[@]}"; do
    EXIT_CODE=0
    STATUS=$(get_ci_status "$branch" || EXIT_CODE=$?)

    # Determine if this branch should continue being monitored
    if [ "$STATUS" = "pending" ] || { [ "$GLOBAL_TRIES" -lt "$MAX_INITIAL_TRIES" ] && [ "$STATUS" = "no status" ]; }; then
      # Still pending, keep monitoring
      echo "$STATUS ($branch)"
      NEW_PENDING+=("$branch")
      GLOBAL_TRIES=$((GLOBAL_TRIES + 1))
      sleep 15
    else
      # Branch completed (success, failure, or error)
      echo "$STATUS ($branch) - COMPLETED"
      COMPLETED_BRANCHES+=("$branch")

      # Send notification
      send_notification "$branch" "$STATUS"

      # Open PR page for this branch
      open_pr_page "$branch"

      # Track exit code (non-zero if any branch failed)
      if [[ $EXIT_CODE -ne 0 ]]; then
        OVERALL_EXIT_CODE=$EXIT_CODE
      fi
    fi
  done

  # Update pending branches array
  PENDING_BRANCHES=("${NEW_PENDING[@]+"${NEW_PENDING[@]}"}")
done

# If the number of completed branches is more than one, give a final summary
if [[ ${#COMPLETED_BRANCHES[@]} -gt 1 ]]; then
  echo ""
  echo "All branches completed!"
  echo "Completed branches: ${COMPLETED_BRANCHES[*]}"
fi

exit $OVERALL_EXIT_CODE
